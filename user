AuditLogController


package com.rwtool.controller;

import com.rwtool.dto.AuditLogDTO;
import com.rwtool.dto.PageResponse;
import com.rwtool.service.AuditLogService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

@RestController
@RequestMapping("/api/audit")
@CrossOrigin(origins = {"http://localhost:3000", "http://127.0.0.1:3000"}, allowCredentials = "true")
public class AuditLogController {
    
    @Autowired
    private AuditLogService auditLogService;
    
    // Get recent activity (last 10 entries)
    @GetMapping("/recent")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<AuditLogDTO>> getRecentActivity() {
        try {
            List<AuditLogDTO> recentActivity = auditLogService.getRecentActivity();
            return ResponseEntity.ok(recentActivity);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
    
    // Get paginated audit logs with filters
    @GetMapping("/logs")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<PageResponse<AuditLogDTO>> getAuditLogs(
            @RequestParam(required = false) String userEmail,
            @RequestParam(required = false) String action,
            @RequestParam(required = false) String role,
            @RequestParam(required = false) String status,
            @RequestParam(required = false, defaultValue = "7days") String dateRange,
            @RequestParam(required = false) String searchTerm,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "10") int size) {
        
        try {
            PageResponse<AuditLogDTO> auditLogs = auditLogService.getAuditLogs(
                    userEmail, action, role, status, dateRange, searchTerm, page, size);
            return ResponseEntity.ok(auditLogs);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
    
    // Get all unique actions for filter dropdown
    @GetMapping("/actions")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<String>> getAllActions() {
        try {
            List<String> actions = auditLogService.getAllActions();
            return ResponseEntity.ok(actions);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
    
    // Get all unique roles for filter dropdown
    @GetMapping("/roles")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<List<String>> getAllRoles() {
        try {
            List<String> roles = auditLogService.getAllRoles();
            return ResponseEntity.ok(roles);
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
    
    // Manual log entry (for testing or manual entries)
    @PostMapping("/log")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<String> createAuditLog(
            @RequestParam String userEmail,
            @RequestParam String role,
            @RequestParam String action,
            @RequestParam String details,
            @RequestParam String status) {
        
        try {
            auditLogService.logActivity(userEmail, role, action, details, status);
            return ResponseEntity.ok("Audit log created successfully");
        } catch (Exception e) {
            return ResponseEntity.internalServerError().body("Failed to create audit log");
        }
    }
    
    // Export audit logs as CSV
    @GetMapping("/export")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<byte[]> exportAuditLogs(
            @RequestParam(required = false) String userEmail,
            @RequestParam(required = false) String action,
            @RequestParam(required = false) String role,
            @RequestParam(required = false) String status,
            @RequestParam(required = false, defaultValue = "7days") String dateRange,
            @RequestParam(required = false) String searchTerm) {
        
        try {
            // Get all audit logs with filters (no pagination for export)
            List<AuditLogDTO> logs = auditLogService.getAllAuditLogsForExport(
                    userEmail, action, role, status, dateRange, searchTerm);
            
            // Generate CSV content
            StringBuilder csvContent = new StringBuilder();
            csvContent.append("Timestamp,User,Role,Action,Details,Status\n");
            
            for (AuditLogDTO log : logs) {
                csvContent.append(escapeCsv(log.getTimestamp())).append(",");
                csvContent.append(escapeCsv(log.getUser())).append(",");
                csvContent.append(escapeCsv(log.getRole())).append(",");
                csvContent.append(escapeCsv(log.getAction())).append(",");
                csvContent.append(escapeCsv(log.getDetails())).append(",");
                csvContent.append(escapeCsv(log.getStatus())).append("\n");
            }
            
            byte[] csvBytes = csvContent.toString().getBytes("UTF-8");
            
            // Generate filename with current timestamp
            String timestamp = LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
            String filename = "audit_logs_" + timestamp + ".csv";
            
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.parseMediaType("text/csv"));
            headers.setContentDispositionFormData("attachment", filename);
            headers.setContentLength(csvBytes.length);
            
            return ResponseEntity.ok()
                    .headers(headers)
                    .body(csvBytes);
                    
        } catch (Exception e) {
            return ResponseEntity.internalServerError().build();
        }
    }
    
    // Helper method to escape CSV values
    private String escapeCsv(String value) {
        if (value == null) {
            return "";
        }
        // Escape quotes and wrap in quotes if contains comma, quote, or newline
        if (value.contains(",") || value.contains("\"") || value.contains("\n")) {
            return "\"" + value.replace("\"", "\"\"") + "\"";
        }
        return value;
    }
}



AuditLogService


package com.rwtool.service;

import com.rwtool.dto.AuditLogDTO;
import com.rwtool.dto.PageResponse;
import com.rwtool.model.AuditLog;
import com.rwtool.repository.AuditLogRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
public class AuditLogService {
    
    @Autowired
    private AuditLogRepository auditLogRepository;
    
    // Create audit log entry
    public void logActivity(String userEmail, String role, String action, String details, String status) {
        AuditLog auditLog = new AuditLog(userEmail, role, action, details, status);
        auditLogRepository.save(auditLog);
    }
    
    
    // Get recent activity (last 10 entries)
    public List<AuditLogDTO> getRecentActivity() {
        List<AuditLog> recentLogs = auditLogRepository.findTop10ByOrderByTimestampDesc();
        return recentLogs.stream()
                .map(AuditLogDTO::new)
                .collect(Collectors.toList());
    }
    
    // Get paginated audit logs with filters
    public PageResponse<AuditLogDTO> getAuditLogs(String userEmail, String action, String role, 
                                                  String status, String dateRange, String searchTerm,
                                                  int page, int size) {
        
        try {
        
        // Create pageable with sorting by timestamp descending
        Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "timestamp"));
        
        // Use simple query without complex filtering for reliability
        Page<AuditLog> auditLogPage = auditLogRepository.findAll(pageable);
        
        // Convert to DTOs
        List<AuditLogDTO> auditLogDTOs = auditLogPage.getContent().stream()
                .map(AuditLogDTO::new)
                .collect(Collectors.toList());
        
        return new PageResponse<>(
                auditLogDTOs,
                auditLogPage.getTotalElements(),
                auditLogPage.getNumber(),
                auditLogPage.getSize(),
                auditLogPage.getTotalPages(),
                auditLogPage.isFirst(),
                auditLogPage.isLast()
        );
        
        } catch (Exception e) {
            System.err.println("Error in getAuditLogs: " + e.getMessage());
            e.printStackTrace();
            // Return empty page response on error
            return new PageResponse<>(
                new ArrayList<>(),
                0L,
                page,
                size,
                0,
                true,
                true
            );
        }
    }
    
    // Get all unique actions for filter dropdown - dynamically from database
    public List<String> getAllActions() {
        try {
            return auditLogRepository.findDistinctActions();
        } catch (Exception e) {
            System.err.println("Error fetching distinct actions: " + e.getMessage());
            return new ArrayList<>();
        }
    }
    
    // Get all unique roles for filter dropdown - dynamically from database
    public List<String> getAllRoles() {
        try {
            return auditLogRepository.findDistinctRoles();
        } catch (Exception e) {
            System.err.println("Error fetching distinct roles: " + e.getMessage());
            return new ArrayList<>();
        }
    }
    
    // Get all audit logs for export (no pagination)
    public List<AuditLogDTO> getAllAuditLogsForExport(String userEmail, String action, String role,
                                                      String status, String dateRange, String searchTerm) {
        try {
            // Get all audit logs sorted by timestamp descending
            Sort sort = Sort.by(Sort.Direction.DESC, "timestamp");
            List<AuditLog> allLogs = auditLogRepository.findAll(sort);
            
            // Convert to DTOs
            return allLogs.stream()
                    .map(AuditLogDTO::new)
                    .collect(Collectors.toList());
                    
        } catch (Exception e) {
            System.err.println("Error in getAllAuditLogsForExport: " + e.getMessage());
            e.printStackTrace();
            return new ArrayList<>();
        }
    }
}





AuditLogRepository

package com.rwtool.repository;

import com.rwtool.model.AuditLog;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface AuditLogRepository extends JpaRepository<AuditLog, Long> {
    
    // Find logs by user email
    List<AuditLog> findByUserEmailContainingIgnoreCase(String userEmail);
    
    // Find logs by action
    List<AuditLog> findByAction(String action);
    
    // Find logs by role
    List<AuditLog> findByRole(String role);
    
    // Find logs by status
    List<AuditLog> findByStatus(String status);
    
    // Find logs within date range
    List<AuditLog> findByTimestampBetween(LocalDateTime startDate, LocalDateTime endDate);
    
    // Find recent logs (limit)
    List<AuditLog> findTop10ByOrderByTimestampDesc();
    
    // Complex search with filters
    @Query("SELECT a FROM AuditLog a WHERE " +
           "(:userEmail IS NULL OR LOWER(a.userEmail) LIKE LOWER(CONCAT('%', :userEmail, '%'))) AND " +
           "(:action IS NULL OR a.action = :action) AND " +
           "(:role IS NULL OR a.role = :role) AND " +
           "(:status IS NULL OR a.status = :status) AND " +
           "(:startDate IS NULL OR a.timestamp >= :startDate) AND " +
           "(:endDate IS NULL OR a.timestamp <= :endDate) AND " +
           "(:searchTerm IS NULL OR (" +
           "LOWER(a.details) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(a.userEmail) LIKE LOWER(CONCAT('%', :searchTerm, '%')) OR " +
           "LOWER(a.action) LIKE LOWER(CONCAT('%', :searchTerm, '%'))))")
    Page<AuditLog> findWithFilters(@Param("userEmail") String userEmail,
                                   @Param("action") String action,
                                   @Param("role") String role,
                                   @Param("status") String status,
                                   @Param("startDate") LocalDateTime startDate,
                                   @Param("endDate") LocalDateTime endDate,
                                   @Param("searchTerm") String searchTerm,
                                   Pageable pageable);
    
    // Get distinct actions dynamically
    @Query("SELECT DISTINCT a.action FROM AuditLog a ORDER BY a.action")
    List<String> findDistinctActions();
    
    // Get distinct roles dynamically
    @Query("SELECT DISTINCT a.role FROM AuditLog a ORDER BY a.role")
    List<String> findDistinctRoles();
}


