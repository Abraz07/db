package rwtool.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.time.LocalDateTime;

// This class represents a USER in your database
// Think of it as a blueprint for how user data is stored

@Entity // This tells Spring: "This is a database table"
@Table(name = "users") // Table name in PostgreSQL will be "users"
@Data // Lombok: Auto-generates getters, setters, toString
@NoArgsConstructor // Creates empty constructor
@AllArgsConstructor // Creates constructor with all fields
public class User {
    
    @Id // This is the Primary Key (unique identifier)
    @GeneratedValue(strategy = GenerationType.IDENTITY) // Auto-increment
    private Long id;
    
    @Column(nullable = false, unique = true) // Username must be unique
    private String username;
    
    @Column(nullable = false, unique = true) // Email must be unique
    private String email;
    
    @Column(nullable = false) // Password is required
    private String password; // Will be encrypted (hashed)
    
    @Column(name = "full_name")
    private String fullName;
    
    @Column(name = "phone_number")
    private String phoneNumber;
    
    @Enumerated(EnumType.STRING) // Store role as text (USER, ADMIN, OPS)
    @Column(nullable = false)
    private Role role; // USER, ADMIN, or OPS
    
    @Column(name = "is_active")
    private Boolean isActive = true; // Account active or not
    
    @CreationTimestamp // Automatically sets creation time
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;
    
    @UpdateTimestamp // Automatically updates when modified
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
}


package rwtool.model;

// This is an ENUM - a fixed set of constants
// Think of it like multiple choice: USER, ADMIN, or OPS only

public enum Role {
    USER,   // Regular user role
    ADMIN,  // Admin role (can manage users, reports, approvals)
    OPS     // Operations role (handles data syncing, storage)
}


package rwtool.repository;

import rwtool.model.Role;
import rwtool.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

// This is the DATABASE ACCESS LAYER
// It provides methods to interact with the "users" table
// Spring automatically implements these methods!

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // Find user by username
    // SQL equivalent: SELECT * FROM users WHERE username = ?
    Optional<User> findByUsername(String username);
    
    // Find user by email
    Optional<User> findByEmail(String email);
    
    // Find user by username AND role (important for role-specific login)
    // SQL: SELECT * FROM users WHERE username = ? AND role = ?
    Optional<User> findByUsernameAndRole(String username, Role role);
    
    // Find user by email AND role
    Optional<User> findByEmailAndRole(String email, Role role);
    
    // Check if username already exists (for signup validation)
    // Returns true/false
    Boolean existsByUsername(String username);
    
    // Check if email already exists
    Boolean existsByEmail(String email);
}

package rwtool.dto;

import rwtool.model.Role;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

// This is what frontend sends when user tries to LOGIN
// Example: { "username": "john", "password": "pass123", "role": "USER" }

@Data
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    private String username;  // User enters username
    private String password;  // User enters password
    private Role role;        // Which login page? USER/ADMIN/OPS
}

package rwtool.security;

import io.jsonwebtoken.*;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.util.Date;

// JWT = JSON Web Token
// Think of it like a secure digital ID card
// After login, user gets this token and shows it for every request

@Component
public class JwtUtils {
    
    // Secret key to sign tokens (from application.properties)
    @Value("${rw24.app.jwtSecret}")
    private String jwtSecret;
    
    // How long token is valid (24 hours = 86400000 ms)
    @Value("${rw24.app.jwtExpirationMs}")
    private int jwtExpirationMs;
    
    // CREATE a token after successful login
    public String generateJwtToken(Authentication authentication) {
        UserDetails userPrincipal = (UserDetails) authentication.getPrincipal();
        
        return Jwts.builder()
                .setSubject(userPrincipal.getUsername()) // Put username in token
                .setIssuedAt(new Date()) // When token was created
                .setExpiration(new Date((new Date()).getTime() + jwtExpirationMs)) // Expiry time
                .signWith(SignatureAlgorithm.HS512, jwtSecret) // Sign with secret key
                .compact();
    }
    
    // EXTRACT username from token
    public String getUserNameFromJwtToken(String token) {
        return Jwts.parser()
                .setSigningKey(jwtSecret)
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }
    
    // VALIDATE token - check if it's real and not expired
    public boolean validateJwtToken(String authToken) {
        try {
            Jwts.parser().setSigningKey(jwtSecret).parseClaimsJws(authToken);
            return true; // Token is valid
        } catch (SignatureException e) {
            System.err.println("Invalid JWT signature: " + e.getMessage());
        } catch (MalformedJwtException e) {
            System.err.println("Invalid JWT token: " + e.getMessage());
        } catch (ExpiredJwtException e) {
            System.err.println("JWT token is expired: " + e.getMessage());
        } catch (UnsupportedJwtException e) {
            System.err.println("JWT token is unsupported: " + e.getMessage());
        } catch (IllegalArgumentException e) {
            System.err.println("JWT claims string is empty: " + e.getMessage());
        }
        
        return false; // Token is NOT valid
    }
}


package rwtool.security;

import rwtool.model.User;
import rwtool.repository.UserRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import java.util.Collection;
import java.util.Collections;

// This service LOADS user data from database during login
// Spring Security uses this to verify credentials

@Service
public class UserDetailsServiceImpl implements UserDetailsService {
    
    @Autowired
    private UserRepository userRepository;
    
    // This method is called when user tries to login
    // It fetches user from database by username
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // Find user in database
        User user = userRepository.findByUsername(username)
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with username: " + username));
        
        // Convert our User to Spring Security's UserDetails format
        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(), // This is the HASHED password
                user.getIsActive(), // Is account active?
                true, // Account not expired
                true, // Credentials not expired
                true, // Account not locked
                getAuthorities(user) // User's roles/permissions
        );
    }
    
    // Convert user role to Spring Security authority
    // Example: Role.USER becomes "ROLE_USER"
    private Collection<? extends GrantedAuthority> getAuthorities(User user) {
        return Collections.singletonList(
                new SimpleGrantedAuthority("ROLE_" + user.getRole().name())
        );
    }
}
